<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title></title>
    <description></description>
    <link></link>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml" />
    
      <item>
        <title>新的开始</title>
        <description>&lt;p&gt;从6号开始，自己一直在休息。
在结束了和blu3gui7ar的谈话后，就算是正式的结束了在leqee的工作。原本和女王大人计划的周末杭州之行也因为一些突发的事情被推到2周之后。（哎，女王有事情要回家）。因此这周的周末就只有一个人在家里面。以前偶尔会内心嫌她话多，但是一下子家里就自己一个人就越来越不适应，必须得承认生活中离不了她了。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;入职体检 X1 (好像重了不少，应该是自己一直不注意锻炼的缘故。锻炼计划还是得安排上计划)&lt;/li&gt;
&lt;li&gt;整理房间 X1 (整理了下房间的布局,感觉清爽了很多，也一洗了女王大人说我懒惰的言论）&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Sun, 09 Mar 2014 00:00:00 +0800</pubDate>
        <link>/2014/03/09/new-start/</link>
        <guid isPermaLink="true">/2014/03/09/new-start/</guid>
      </item>
    
      <item>
        <title>Mac通过homebrew 安装mysql</title>
        <description>&lt;p&gt;通过brew安装mysql:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;shell&quot;&gt;brew install mysql
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;等成功安装完成，想要登录的时候出问题了：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;shell&quot;&gt;ERROR 2002 (HY000): Can not connect to local MySQL server through socket &#39;/tmp/mysql.sock&#39; (2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;google了一下，找到答案原来，还没彻底安装完成：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;shell&quot;&gt;brew info mysql
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到如下命令，执行之:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;shell&quot;&gt;ln -sfv /usr/local/opt/mysql/homebrew.mxcl.mysql.plist ~/Library/LaunchAgents
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面我们还需要启动mysql服务：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;shell&quot;&gt;mysql.server start
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用如下命令登录即可：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;shell&quot;&gt;mysql -uroot  #初始没有设置密码
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;mysql 修改root密码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;mysql&quot;&gt;$ mysql -u root
mysql&amp;gt; use mysql;
mysql&amp;gt; update user set password=PASSWORD(&quot;NEWPASSWORD&quot;) where User=&#39;root&#39;;
mysql&amp;gt; flush privileges;
mysql&amp;gt; quit
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;done!&lt;/p&gt;
</description>
        <pubDate>Sat, 01 Feb 2014 00:00:00 +0800</pubDate>
        <link>/2014/02/01/install-mysql-in-osx/</link>
        <guid isPermaLink="true">/2014/02/01/install-mysql-in-osx/</guid>
      </item>
    
      <item>
        <title>nginx ci</title>
        <description>&lt;p&gt;ci 的nginx 配置&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;nginx&quot;&gt;server {

    listen 80;
    server_name  you.service.name

    error_log /path/to/log;
    access_log /path/to/log;

    location / {
       root /path/to/file
       index index.php index.html index.htm;
       if (-f $request_filename) {
         expires max;
         break;
       }

       #if (!-e $request_filename) {
       #    rewrite ^/(.*)$ /index.php/$1 last;
       #}
        if ($request_filename !~ (js|css|images|robots/.txt|index/.php.*) ) {
            rewrite ^/(.*)$ /index.php/$1 last;
            break;
        }

    }

    location ~ \.php($|/) {
        root           /path/to/file
        fastcgi_pass   127.0.0.1:9000;
        fastcgi_index index.php;
        fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;
        fastcgi_param  PATH_INFO  $fastcgi_path_info;
        fastcgi_split_path_info ^(.+\.php)(.*)$;
        include fastcgi_params;
    }

}
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Mon, 20 Jan 2014 00:00:00 +0800</pubDate>
        <link>/2014/01/20/nginx-ci/</link>
        <guid isPermaLink="true">/2014/01/20/nginx-ci/</guid>
      </item>
    
      <item>
        <title>gitlab ssh 提交代码</title>
        <description>&lt;p&gt;最近公司版本管理工具尝试在用&lt;code&gt;git&lt;/code&gt;，通过&lt;code&gt;gitlab&lt;/code&gt; 管理代码。总结了ssh pull/push 代码时遇到的问题和解决的方法，供大家参考。&lt;/p&gt;

&lt;h3&gt;1.创建ssh 公钥和私钥&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;sh&quot;&gt;cd ~/.ssh &amp;amp;&amp;amp; ssh-keygen #创建ssh key
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看到如下提示:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Generating public/private rsa key pair.
 Enter file in which to save the key (/home/foursk/.ssh/id_rsa): test #输入需要的name
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;创建完之后在 .ssh 目录会看到 两个文件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;sh&quot;&gt;test test.pub
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中&lt;code&gt;.pub&lt;/code&gt; 结尾的就是公钥&lt;/p&gt;

&lt;h3&gt;2.复制公钥内容粘贴到自己的gitlab&lt;/h3&gt;

&lt;p&gt;单击gitlab &lt;code&gt;Add Public Key&lt;/code&gt; 按钮 粘贴内容&lt;/p&gt;

&lt;h3&gt;3.设置ssh&lt;/h3&gt;

&lt;p&gt;创建完&lt;code&gt;ssh-key&lt;/code&gt;以后，我们需要让git提交的时候能够使用我们的&lt;code&gt;ssh-key&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;sh&quot;&gt;touch ~/.ssh/config   #创建config
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编辑config&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;sh&quot;&gt;Host you.host
    Hostname your.host.name
    User git
    IdentityFile ~/.ssh/test
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;重启ssh服务&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;sh&quot;&gt;service ssh restart
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Mon, 20 Jan 2014 00:00:00 +0800</pubDate>
        <link>/2014/01/20/git-gitlab/</link>
        <guid isPermaLink="true">/2014/01/20/git-gitlab/</guid>
      </item>
    
      <item>
        <title>nginx 配置总结</title>
        <description>&lt;h3&gt;基本设置&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;nginx&quot;&gt;#定义Nginx运行的用户和用户组
user www-data www-data;

#nginx进程数，建议设置为等于CPU总核心数。
worker_processes 4;

#进程文件
pid /var/run/nginx.pid;

#一个nginx进程打开的最多文件描述符数目，理论值应该是最多打开文件数（系统的值ulimit -n）与nginx进程数相除，但是nginx分配请求并不均匀，所以建议与ulimit -n的值保持一致。
worker_rlimit_nofile 65535;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;工作模式与连接数上限&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;nginx&quot;&gt;events
{
#参考事件模型，use [ kqueue | rtsig | epoll | /dev/poll | select | poll ]; epoll模型是Linux 2.6以上版本内核中的高性能网络I/O模型，如果跑在FreeBSD上面，就用kqueue模型。
use epoll;
#单个进程最大连接数（最大连接数=连接数*进程数）
worker_connections 65535;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;设定http服务器&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;nginx&quot;&gt;http
{
  include mime.types; #文件扩展名与文件类型映射表
  default_type application/octet-stream; #默认文件类型
  #charset utf-8; #默认编码
  server_names_hash_bucket_size 128; #服务器名字的hash表大小
  client_header_buffer_size 32k; #上传文件大小限制
  large_client_header_buffers 4 64k; #设定请求缓
  client_max_body_size 8m; #设定请求缓
  sendfile on; #开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，对于普通应用设为 on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载。注意：如果图片显示不正常把这个改成off。
  autoindex on; #开启目录列表访问，合适下载服务器，默认关闭。
  tcp_nopush on; #防止网络阻塞
  tcp_nodelay on; #防止网络阻塞
  keepalive_timeout 120; #长连接超时时间，单位是秒

  #FastCGI相关参数是为了改善网站的性能：减少资源占用，提高访问速度。下面参数看字面意思都能理解。
  fastcgi_connect_timeout 300;
  fastcgi_send_timeout 300;
  fastcgi_read_timeout 300;
  fastcgi_buffer_size 64k;
  fastcgi_buffers 4 64k;
  fastcgi_busy_buffers_size 128k;
  fastcgi_temp_file_write_size 128k;

  #gzip模块设置
  gzip on; #开启gzip压缩输出
  gzip_min_length 1k; #最小压缩文件大小
  gzip_buffers 4 16k; #压缩缓冲区
  gzip_http_version 1.0; #压缩版本（默认1.1，前端如果是squid2.5请使用1.0）
  gzip_comp_level 2; #压缩等级
  gzip_types text/plain application/x-javascript text/css application/xml;
  #压缩类型，默认就已经包含text/html，所以下面就不用再写了，写上去也不会有问题，但是会有一个warn。
  gzip_vary on;
  #limit_zone crawler $binary_remote_addr 10m; #开启限制IP连接数的时候需要使用

}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;nginx&quot;&gt;http {
    access_log /etc/nginx/logs/access.log;
    error_log /etc/nginx/logs/error.log;

    include       mime.types;
    default_type  application/octet-stream;

    log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;
                      &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;
                      &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot; $host&#39;;


    #sendfile        on;
    #tcp_nopush     on;

    #keepalive_timeout  0;
    #keepalive_timeout  65;

    sendfile        on;
    tcp_nopush      on;
    tcp_nodelay     on;
    server_tokens   off;

    #keepalive_timeout  0;
    keepalive_timeout  65;


    gzip on;
    gzip_min_length  2100;
    gzip_buffers     4 8k;
    gzip_types       text/plain text/css application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript image/x-icon;

    output_buffers   1 32k;
    postpone_output  1460;
    client_max_body_size 20m;

    client_header_buffer_size 64k;
    large_client_header_buffers 4 128k;

    fastcgi_connect_timeout 3000;
    fastcgi_send_timeout 3000;
    fastcgi_read_timeout 3000;
    fastcgi_buffer_size 64k;
    fastcgi_buffers 4 64k;
    fastcgi_busy_buffers_size 128k;
    fastcgi_temp_file_write_size 128k;
    fastcgi_intercept_errors on; ### resolve the problem: no input file specified


     #include vhost
     include /etc/nginx/conf.d/*.conf;
     include  /etc/nginx/vhosts/*.conf;

}
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Thu, 16 Jan 2014 00:00:00 +0800</pubDate>
        <link>/2014/01/16/nginx-conf/</link>
        <guid isPermaLink="true">/2014/01/16/nginx-conf/</guid>
      </item>
    
      <item>
        <title>symfony2 使用总结</title>
        <description>&lt;h3&gt;symfony2 目录结构&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;sh&quot;&gt;    sf2/ &amp;lt;- Symfony2解压目录
        app/ &amp;lt;- 存放symfony的核心文件的目录
            cache/ &amp;lt;- 存放缓存文件的目录
            config/ &amp;lt;- 存放应用程序全局配置的目录
            logs/ &amp;lt;- 存放日志的目录
        src/ &amp;lt;- 应用程序源代码
            ...
        vendor/ &amp;lt;- 供应商或第三方的模组和插件
            ...
        web/ &amp;lt;- Web入口
            app_dev.php &amp;lt;- 生产环境下的前端控制器
            ...
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;配置文件&lt;/h3&gt;

&lt;p&gt;配置文件路径 &lt;code&gt;/sf2/app/config/parameters.yml&lt;/code&gt;&lt;/p&gt;

&lt;h3&gt;创建Bundle&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;php&quot;&gt;php app/console generate:bundle --namnespace=path/file --format=yml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;之后会有一系列的确认&lt;/p&gt;

&lt;h3&gt;注册Bundle&lt;/h3&gt;

&lt;p&gt;使用&lt;code&gt;app/console&lt;/code&gt; 工具能够自动帮我们注册Bundle，可以节省很多时间，但是有的时候我们需要修改bundle名字，修改namespace，那么就需要手动注册Bundle。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;php&quot;&gt;//app/AppKernel.php

&amp;lt;?php

use Symfony\Component\HttpKernel\Kernel;
use Symfony\Component\Config\Loader\LoaderInterface;

class AppKernel extends Kernel
{
    public function registerBundles()
    {
        $bundles = array(
            new Symfony\Bundle\FrameworkBundle\FrameworkBundle(),
            new Symfony\Bundle\SecurityBundle\SecurityBundle(),
            new Symfony\Bundle\TwigBundle\TwigBundle(),
            new Symfony\Bundle\MonologBundle\MonologBundle(),
            new Symfony\Bundle\SwiftmailerBundle\SwiftmailerBundle(),
            new Symfony\Bundle\AsseticBundle\AsseticBundle(),
            new Doctrine\Bundle\DoctrineBundle\DoctrineBundle(),
            new Sensio\Bundle\FrameworkExtraBundle\SensioFrameworkExtraBundle(),
            new Acme\StudyBundle\AcmeStudyBundle(),
        );

        if (in_array($this-&amp;gt;getEnvironment(), array(&#39;dev&#39;, &#39;test&#39;))) {
            $bundles[] = new Acme\DemoBundle\AcmeDemoBundle();
            $bundles[] = new Symfony\Bundle\WebProfilerBundle\WebProfilerBundle();
            $bundles[] = new Sensio\Bundle\DistributionBundle\SensioDistributionBundle();
            $bundles[] = new Sensio\Bundle\GeneratorBundle\SensioGeneratorBundle();
        }

        return $bundles;
    }

    public function registerContainerConfiguration(LoaderInterface $loader)
    {
        $loader-&amp;gt;load(__DIR__.&#39;/config/config_&#39;.$this-&amp;gt;getEnvironment().&#39;.yml&#39;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中 &lt;code&gt;new Acme\StudyBundle\AcmeStudyBundle()&lt;/code&gt; 便是我们新注册的Bundle&lt;/p&gt;
</description>
        <pubDate>Wed, 15 Jan 2014 00:00:00 +0800</pubDate>
        <link>/2014/01/15/start-with-symfony2/</link>
        <guid isPermaLink="true">/2014/01/15/start-with-symfony2/</guid>
      </item>
    
      <item>
        <title>php-pear</title>
        <description>&lt;pre&gt;&lt;code class=&quot;sh&quot;&gt;sudo apt-get install php-pear
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Wed, 15 Jan 2014 00:00:00 +0800</pubDate>
        <link>/2014/01/15/php-pear/</link>
        <guid isPermaLink="true">/2014/01/15/php-pear/</guid>
      </item>
    
      <item>
        <title>php错误报告</title>
        <description>
</description>
        <pubDate>Tue, 14 Jan 2014 00:00:00 +0800</pubDate>
        <link>/2014/01/14/php-error-reporting/</link>
        <guid isPermaLink="true">/2014/01/14/php-error-reporting/</guid>
      </item>
    
      <item>
        <title>Test-Private-Function-In-Php</title>
        <description>&lt;h2&gt;开始 symfony2&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;sh&quot;&gt;php composer.phar create-project symfony/framework-standard-edition path/ 2.4.1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中 &lt;code&gt;php composer.phar&lt;/code&gt; 是使用composer 命令 ， &lt;code&gt;path/&lt;/code&gt; 是安装路径 ， &lt;code&gt;2.4.1&lt;/code&gt; 是版本号&lt;/p&gt;
</description>
        <pubDate>Mon, 13 Jan 2014 00:00:00 +0800</pubDate>
        <link>/2014/01/13/symfony2-1/</link>
        <guid isPermaLink="true">/2014/01/13/symfony2-1/</guid>
      </item>
    
      <item>
        <title>OSX 中vim的复制和粘贴</title>
        <description>&lt;h3&gt;Term2 + Vim 下的复制粘贴&lt;/h3&gt;

&lt;p&gt;安装 Vim 时如果打开了 clipboard 特性 ( &lt;code&gt;vim --version | grep clipboard&lt;/code&gt;，系统自带的 Vim 是没有打开的，不想自己编译的话也可以通过安装 Macvim 然后将 vim alias 到 mvim )，则可以使用 * 寄存器（ Vim 有很多剪贴板，mac 下的系统剪贴板是 *，还有 + ?），通过 &lt;code&gt;&quot;*y&lt;/code&gt; 和 &lt;code&gt;&quot;*p&lt;/code&gt; 就可以完成复制粘贴到系统剪贴板，在 &lt;code&gt;.vimrc&lt;/code&gt; 里加入了&lt;code&gt;set cilpboard=unnamed&lt;/code&gt;后就不用加 &lt;code&gt;&quot;*&lt;/code&gt; 直接 &lt;code&gt;yy&lt;/code&gt; 了。没有&lt;code&gt;+clipboard&lt;/code&gt;的话也没关系，我们还有 mac 下的 &lt;code&gt;pbcopy&lt;/code&gt; 和 &lt;code&gt;pbpaste&lt;/code&gt; 命令可以使用。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;vim&quot;&gt;vmap &lt;span class=&quot;c&quot;&gt;&amp;quot;+y :w !pbcopy&amp;lt;CR&amp;gt;&amp;lt;CR&amp;gt;&lt;/span&gt;
nmap &lt;span class=&quot;c&quot;&gt;&amp;quot;+p :r !pbpaste&amp;lt;CR&amp;gt;&amp;lt;CR&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;iTerm2+Tmux+Vim 下的复制粘贴&lt;/h3&gt;

&lt;p&gt;不过同时作为一个 Tmux 用户，一般情况下Vim里的复制会遇到问题。Tmux 自己有提供一套复制粘贴功能，通过 Tmux 自己的复制机制只是将选中的内容复制到自己的 buffer 中，而由于我没怎么搞清的（权限相关）原因， Tmux 自己又不能访问系统剪贴板，所以直接在 Vim 里复制到系统剪贴板（以及从系统剪贴板拿东西）是不行的。reattach-to-user-namespace 则是用来解决 tmux 中 pbcopy 和 pbpaste 不能正常访问的问题，具体是什么问题而又怎么解决反正我也不是很懂去链接里看吧。。。&lt;/p&gt;

&lt;p&gt;打开 Vim 对系统 clipboard 支持（可以自己编译或通过安装 Macvim 解决）。
brew 安装 reattach-to-user-namespace
.vimrc 中加入 set cilpboard=unnamed
在 .tmux.conf 中加入&lt;/p&gt;

&lt;p&gt;set-option -g default-command &quot;reattach-to-user-namespace -l zsh&quot;&lt;/p&gt;

&lt;h3&gt;Tmux pannel中的复制&lt;/h3&gt;

&lt;p&gt;如果一个 Tmux window 中有两个水平的 pannel ，直接用鼠标选中然后复制是不能分辨 pannel 的，即复制一行会贯穿两个 pannel 。&lt;/p&gt;

&lt;p&gt;添加以下到 &lt;code&gt;.tmux.conf&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;vim&quot;&gt;# Use &lt;span class=&quot;k&quot;&gt;vim&lt;/span&gt; keybindings &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; copy &lt;span class=&quot;k&quot;&gt;mode&lt;/span&gt;
setw &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;g&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;mode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;-&lt;/span&gt;keys &lt;span class=&quot;k&quot;&gt;vi&lt;/span&gt;

# Setup &lt;span class=&quot;s1&quot;&gt;&amp;#39;v&amp;#39;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;to&lt;/span&gt; begin &lt;span class=&quot;nb&quot;&gt;selection&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; Vim （seems require Tmux &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;.&lt;span class=&quot;m&quot;&gt;8&lt;/span&gt;）

# 一般情况中，&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;prefix&lt;span class=&quot;p&quot;&gt;&amp;gt;-&lt;/span&gt;[ 进入复制模式后 &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;space&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; 开始选中，&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;enter&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; 结束选中 &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;copy &lt;span class=&quot;k&quot;&gt;to&lt;/span&gt; buffer&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

bind&lt;span class=&quot;p&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;vi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;-&lt;/span&gt;copy &lt;span class=&quot;k&quot;&gt;v&lt;/span&gt; begin&lt;span class=&quot;p&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;selection&lt;/span&gt;
bind&lt;span class=&quot;p&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;vi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;-&lt;/span&gt;copy &lt;span class=&quot;k&quot;&gt;y&lt;/span&gt; copy&lt;span class=&quot;p&quot;&gt;-&lt;/span&gt;pipe &lt;span class=&quot;s2&quot;&gt;&amp;quot;reattach-to-user-namespace pbcopy&amp;quot;&lt;/span&gt;

# Update default binding of `Enter` &lt;span class=&quot;k&quot;&gt;to&lt;/span&gt; also use copy&lt;span class=&quot;p&quot;&gt;-&lt;/span&gt;pipe
unbind &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;vi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;-&lt;/span&gt;copy Enter
bind&lt;span class=&quot;p&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;vi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;-&lt;/span&gt;copy Enter copy&lt;span class=&quot;p&quot;&gt;-&lt;/span&gt;pipe &lt;span class=&quot;s2&quot;&gt;&amp;quot;reattach-to-user-namespace pbcopy&amp;quot;&lt;/span&gt;

`&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;prefix&lt;span class=&quot;p&quot;&gt;&amp;gt;-&lt;/span&gt;[ `进入 Tmux 的复制模式，使用 Vim 操作来进行移动，&lt;span class=&quot;k&quot;&gt;v&lt;/span&gt; 选中内容，&lt;span class=&quot;k&quot;&gt;y&lt;/span&gt; 进行复制，首先内容会复制到 Tmux 的 &lt;span class=&quot;nb&quot;&gt;paste&lt;/span&gt; buffer 中，再由 pbcopy 来复制到系统的剪贴板中。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;vim 的 paste mode&lt;/h3&gt;

&lt;p&gt;Vim中 ⌘+V 的粘贴
有时候如果我们想用 &lt;code&gt;⌘+v&lt;/code&gt; 来进行粘贴，直接粘贴的话内容是一段一段复制进去的，并且还伴有一些我们不希望出现的缩进或者其它奇怪的东西，我们可以进入 Vim 的 paste mode 来进行正常的粘贴。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;vim&quot;&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;paste&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;&amp;quot;开启paste 模式&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;nopaste&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;&amp;quot;关闭paste 模式&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;pastetoggle&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;&amp;quot;toggle 模式&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;



</description>
        <pubDate>Mon, 13 Jan 2014 00:00:00 +0800</pubDate>
        <link>/2014/01/13/paste-in-osx-terminal/</link>
        <guid isPermaLink="true">/2014/01/13/paste-in-osx-terminal/</guid>
      </item>
    
  </channel>
</rss>
