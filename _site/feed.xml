<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title></title>
    <description></description>
    <link></link>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml" />
    
      <item>
        <title>nginx ci</title>
        <description>&lt;p&gt;ci 的nginx 配置&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;nginx&quot;&gt;server {

    listen 80;
    server_name  you.service.name

    error_log /path/to/log;
    access_log /path/to/log;

    location / {
       root /path/to/file
       index index.php index.html index.htm;
       if (-f $request_filename) {
         expires max;
         break;
       }

       #if (!-e $request_filename) {
       #    rewrite ^/(.*)$ /index.php/$1 last;
       #}
        if ($request_filename !~ (js|css|images|robots/.txt|index/.php.*) ) {
            rewrite ^/(.*)$ /index.php/$1 last;
            break;
        }

    }

    location ~ \.php($|/) {
        root           /path/to/file
        fastcgi_pass   127.0.0.1:9000;
        fastcgi_index index.php;
        fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;
        fastcgi_param  PATH_INFO  $fastcgi_path_info;
        fastcgi_split_path_info ^(.+\.php)(.*)$;
        include fastcgi_params;
    }

}
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Mon, 20 Jan 2014 00:00:00 +0800</pubDate>
        <link>/2014/01/20/nginx-ci/</link>
        <guid isPermaLink="true">/2014/01/20/nginx-ci/</guid>
      </item>
    
      <item>
        <title>gitlab ssh 提交代码</title>
        <description>&lt;p&gt;最近公司版本管理工具尝试在用&lt;code&gt;git&lt;/code&gt;，通过&lt;code&gt;gitlab&lt;/code&gt; 管理代码。总结了ssh pull/push 代码时遇到的问题和解决的方法，供大家参考。&lt;/p&gt;

&lt;h3&gt;1.创建ssh 公钥和私钥&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;sh&quot;&gt;cd ~/.ssh &amp;amp;&amp;amp; ssh-keygen #创建ssh key
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看到如下提示:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Generating public/private rsa key pair.
 Enter file in which to save the key (/home/foursk/.ssh/id_rsa): test #输入需要的name
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;创建完之后在 .ssh 目录会看到 两个文件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;sh&quot;&gt;test test.pub
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中&lt;code&gt;.pub&lt;/code&gt; 结尾的就是公钥&lt;/p&gt;

&lt;h3&gt;2.复制公钥内容粘贴到自己的gitlab&lt;/h3&gt;

&lt;p&gt;单击gitlab &lt;code&gt;Add Public Key&lt;/code&gt; 按钮 粘贴内容&lt;/p&gt;

&lt;h3&gt;3.设置ssh&lt;/h3&gt;

&lt;p&gt;创建完&lt;code&gt;ssh-key&lt;/code&gt;以后，我们需要让git提交的时候能够使用我们的&lt;code&gt;ssh-key&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;sh&quot;&gt;touch ~/.ssh/config   #创建config
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编辑config&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;sh&quot;&gt;Host you.host
    Hostname your.host.name
    User git
    IdentityFile ~/.ssh/test
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;重启ssh服务&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;sh&quot;&gt;service ssh restart
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Mon, 20 Jan 2014 00:00:00 +0800</pubDate>
        <link>/2014/01/20/git-gitlab/</link>
        <guid isPermaLink="true">/2014/01/20/git-gitlab/</guid>
      </item>
    
      <item>
        <title>nginx 配置总结</title>
        <description>&lt;h3&gt;基本设置&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;nginx&quot;&gt;#定义Nginx运行的用户和用户组
user www-data www-data;

#nginx进程数，建议设置为等于CPU总核心数。
worker_processes 4;

#进程文件
pid /var/run/nginx.pid;

#一个nginx进程打开的最多文件描述符数目，理论值应该是最多打开文件数（系统的值ulimit -n）与nginx进程数相除，但是nginx分配请求并不均匀，所以建议与ulimit -n的值保持一致。
worker_rlimit_nofile 65535;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;工作模式与连接数上限&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;nginx&quot;&gt;events
{
#参考事件模型，use [ kqueue | rtsig | epoll | /dev/poll | select | poll ]; epoll模型是Linux 2.6以上版本内核中的高性能网络I/O模型，如果跑在FreeBSD上面，就用kqueue模型。
use epoll;
#单个进程最大连接数（最大连接数=连接数*进程数）
worker_connections 65535;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;设定http服务器&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;nginx&quot;&gt;http
{
  include mime.types; #文件扩展名与文件类型映射表
  default_type application/octet-stream; #默认文件类型
  #charset utf-8; #默认编码
  server_names_hash_bucket_size 128; #服务器名字的hash表大小
  client_header_buffer_size 32k; #上传文件大小限制
  large_client_header_buffers 4 64k; #设定请求缓
  client_max_body_size 8m; #设定请求缓
  sendfile on; #开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，对于普通应用设为 on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载。注意：如果图片显示不正常把这个改成off。
  autoindex on; #开启目录列表访问，合适下载服务器，默认关闭。
  tcp_nopush on; #防止网络阻塞
  tcp_nodelay on; #防止网络阻塞
  keepalive_timeout 120; #长连接超时时间，单位是秒

  #FastCGI相关参数是为了改善网站的性能：减少资源占用，提高访问速度。下面参数看字面意思都能理解。
  fastcgi_connect_timeout 300;
  fastcgi_send_timeout 300;
  fastcgi_read_timeout 300;
  fastcgi_buffer_size 64k;
  fastcgi_buffers 4 64k;
  fastcgi_busy_buffers_size 128k;
  fastcgi_temp_file_write_size 128k;

  #gzip模块设置
  gzip on; #开启gzip压缩输出
  gzip_min_length 1k; #最小压缩文件大小
  gzip_buffers 4 16k; #压缩缓冲区
  gzip_http_version 1.0; #压缩版本（默认1.1，前端如果是squid2.5请使用1.0）
  gzip_comp_level 2; #压缩等级
  gzip_types text/plain application/x-javascript text/css application/xml;
  #压缩类型，默认就已经包含text/html，所以下面就不用再写了，写上去也不会有问题，但是会有一个warn。
  gzip_vary on;
  #limit_zone crawler $binary_remote_addr 10m; #开启限制IP连接数的时候需要使用

}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;nginx&quot;&gt;http {
    access_log /etc/nginx/logs/access.log;
    error_log /etc/nginx/logs/error.log;

    include       mime.types;
    default_type  application/octet-stream;

    log_format  main  '$remote_addr - $remote_user [$time_local] &quot;$request&quot; '
                      '$status $body_bytes_sent &quot;$http_referer&quot; '
                      '&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot; $host';


    #sendfile        on;
    #tcp_nopush     on;

    #keepalive_timeout  0;
    #keepalive_timeout  65;

    sendfile        on;
    tcp_nopush      on;
    tcp_nodelay     on;
    server_tokens   off;

    #keepalive_timeout  0;
    keepalive_timeout  65;


    gzip on;
    gzip_min_length  2100;
    gzip_buffers     4 8k;
    gzip_types       text/plain text/css application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript image/x-icon;

    output_buffers   1 32k;
    postpone_output  1460;
    client_max_body_size 20m;

    client_header_buffer_size 64k;
    large_client_header_buffers 4 128k;

    fastcgi_connect_timeout 3000;
    fastcgi_send_timeout 3000;
    fastcgi_read_timeout 3000;
    fastcgi_buffer_size 64k;
    fastcgi_buffers 4 64k;
    fastcgi_busy_buffers_size 128k;
    fastcgi_temp_file_write_size 128k;
    fastcgi_intercept_errors on; ### resolve the problem: no input file specified


     #include vhost
     include /etc/nginx/conf.d/*.conf;
     include  /etc/nginx/vhosts/*.conf;

}
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Thu, 16 Jan 2014 00:00:00 +0800</pubDate>
        <link>/2014/01/16/nginx-conf/</link>
        <guid isPermaLink="true">/2014/01/16/nginx-conf/</guid>
      </item>
    
      <item>
        <title>symfony2 使用总结</title>
        <description>&lt;h3&gt;symfony2 目录结构&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;sh&quot;&gt;    sf2/ &amp;lt;- Symfony2解压目录
        app/ &amp;lt;- 存放symfony的核心文件的目录
            cache/ &amp;lt;- 存放缓存文件的目录
            config/ &amp;lt;- 存放应用程序全局配置的目录
            logs/ &amp;lt;- 存放日志的目录
        src/ &amp;lt;- 应用程序源代码
            ...
        vendor/ &amp;lt;- 供应商或第三方的模组和插件
            ...
        web/ &amp;lt;- Web入口
            app_dev.php &amp;lt;- 生产环境下的前端控制器
            ...
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;配置文件&lt;/h3&gt;

&lt;p&gt;配置文件路径 &lt;code&gt;/sf2/app/config/parameters.yml&lt;/code&gt;&lt;/p&gt;

&lt;h3&gt;创建Bundle&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;php&quot;&gt;php app/console generate:bundle --namnespace=path/file --format=yml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;之后会有一系列的确认&lt;/p&gt;

&lt;h3&gt;注册Bundle&lt;/h3&gt;

&lt;p&gt;使用&lt;code&gt;app/console&lt;/code&gt; 工具能够自动帮我们注册Bundle，可以节省很多时间，但是有的时候我们需要修改bundle名字，修改namespace，那么就需要手动注册Bundle。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;php&quot;&gt;//app/AppKernel.php

&amp;lt;?php

use Symfony\Component\HttpKernel\Kernel;
use Symfony\Component\Config\Loader\LoaderInterface;

class AppKernel extends Kernel
{
    public function registerBundles()
    {
        $bundles = array(
            new Symfony\Bundle\FrameworkBundle\FrameworkBundle(),
            new Symfony\Bundle\SecurityBundle\SecurityBundle(),
            new Symfony\Bundle\TwigBundle\TwigBundle(),
            new Symfony\Bundle\MonologBundle\MonologBundle(),
            new Symfony\Bundle\SwiftmailerBundle\SwiftmailerBundle(),
            new Symfony\Bundle\AsseticBundle\AsseticBundle(),
            new Doctrine\Bundle\DoctrineBundle\DoctrineBundle(),
            new Sensio\Bundle\FrameworkExtraBundle\SensioFrameworkExtraBundle(),
            new Acme\StudyBundle\AcmeStudyBundle(),
        );

        if (in_array($this-&amp;gt;getEnvironment(), array('dev', 'test'))) {
            $bundles[] = new Acme\DemoBundle\AcmeDemoBundle();
            $bundles[] = new Symfony\Bundle\WebProfilerBundle\WebProfilerBundle();
            $bundles[] = new Sensio\Bundle\DistributionBundle\SensioDistributionBundle();
            $bundles[] = new Sensio\Bundle\GeneratorBundle\SensioGeneratorBundle();
        }

        return $bundles;
    }

    public function registerContainerConfiguration(LoaderInterface $loader)
    {
        $loader-&amp;gt;load(__DIR__.'/config/config_'.$this-&amp;gt;getEnvironment().'.yml');
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中 &lt;code&gt;new Acme\StudyBundle\AcmeStudyBundle()&lt;/code&gt; 便是我们新注册的Bundle&lt;/p&gt;
</description>
        <pubDate>Wed, 15 Jan 2014 00:00:00 +0800</pubDate>
        <link>/2014/01/15/start-with-symfony2/</link>
        <guid isPermaLink="true">/2014/01/15/start-with-symfony2/</guid>
      </item>
    
      <item>
        <title>php-pear</title>
        <description>&lt;pre&gt;&lt;code class=&quot;sh&quot;&gt;sudo apt-get install php-pear
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Wed, 15 Jan 2014 00:00:00 +0800</pubDate>
        <link>/2014/01/15/php-pear/</link>
        <guid isPermaLink="true">/2014/01/15/php-pear/</guid>
      </item>
    
      <item>
        <title>php错误报告</title>
        <description>
</description>
        <pubDate>Tue, 14 Jan 2014 00:00:00 +0800</pubDate>
        <link>/2014/01/14/php-error-reporting/</link>
        <guid isPermaLink="true">/2014/01/14/php-error-reporting/</guid>
      </item>
    
      <item>
        <title>Test-Private-Function-In-Php</title>
        <description>&lt;h2&gt;开始 symfony2&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;sh&quot;&gt;php composer.phar create-project symfony/framework-standard-edition path/ 2.4.1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中 &lt;code&gt;php composer.phar&lt;/code&gt; 是使用composer 命令 ， &lt;code&gt;path/&lt;/code&gt; 是安装路径 ， &lt;code&gt;2.4.1&lt;/code&gt; 是版本号&lt;/p&gt;
</description>
        <pubDate>Mon, 13 Jan 2014 00:00:00 +0800</pubDate>
        <link>/2014/01/13/symfony2-1/</link>
        <guid isPermaLink="true">/2014/01/13/symfony2-1/</guid>
      </item>
    
      <item>
        <title>OSX 中vim的复制和粘贴</title>
        <description>&lt;h3&gt;Term2 + Vim 下的复制粘贴&lt;/h3&gt;

&lt;p&gt;安装 Vim 时如果打开了 clipboard 特性 ( &lt;code&gt;vim --version | grep clipboard&lt;/code&gt;，系统自带的 Vim 是没有打开的，不想自己编译的话也可以通过安装 Macvim 然后将 vim alias 到 mvim )，则可以使用 * 寄存器（ Vim 有很多剪贴板，mac 下的系统剪贴板是 *，还有 + ?），通过 &lt;code&gt;&quot;*y&lt;/code&gt; 和 &lt;code&gt;&quot;*p&lt;/code&gt; 就可以完成复制粘贴到系统剪贴板，在 &lt;code&gt;.vimrc&lt;/code&gt; 里加入了&lt;code&gt;set cilpboard=unnamed&lt;/code&gt;后就不用加 &lt;code&gt;&quot;*&lt;/code&gt; 直接 &lt;code&gt;yy&lt;/code&gt; 了。没有&lt;code&gt;+clipboard&lt;/code&gt;的话也没关系，我们还有 mac 下的 &lt;code&gt;pbcopy&lt;/code&gt; 和 &lt;code&gt;pbpaste&lt;/code&gt; 命令可以使用。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;vim&quot;&gt;vmap &quot;+y :w !pbcopy&amp;lt;CR&amp;gt;&amp;lt;CR&amp;gt;
nmap &quot;+p :r !pbpaste&amp;lt;CR&amp;gt;&amp;lt;CR&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;iTerm2+Tmux+Vim 下的复制粘贴&lt;/h3&gt;

&lt;p&gt;不过同时作为一个 Tmux 用户，一般情况下Vim里的复制会遇到问题。Tmux 自己有提供一套复制粘贴功能，通过 Tmux 自己的复制机制只是将选中的内容复制到自己的 buffer 中，而由于我没怎么搞清的（权限相关）原因， Tmux 自己又不能访问系统剪贴板，所以直接在 Vim 里复制到系统剪贴板（以及从系统剪贴板拿东西）是不行的。reattach-to-user-namespace 则是用来解决 tmux 中 pbcopy 和 pbpaste 不能正常访问的问题，具体是什么问题而又怎么解决反正我也不是很懂去链接里看吧。。。&lt;/p&gt;

&lt;p&gt;打开 Vim 对系统 clipboard 支持（可以自己编译或通过安装 Macvim 解决）。
brew 安装 reattach-to-user-namespace
.vimrc 中加入 set cilpboard=unnamed
在 .tmux.conf 中加入&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;sh&quot;&gt;set-option -g default-command &quot;reattach-to-user-namespace -l zsh&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Tmux pannel中的复制&lt;/h3&gt;

&lt;p&gt;如果一个 Tmux window 中有两个水平的 pannel ，直接用鼠标选中然后复制是不能分辨 pannel 的，即复制一行会贯穿两个 pannel 。&lt;/p&gt;

&lt;p&gt;添加以下到 &lt;code&gt;.tmux.conf&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;sh&quot;&gt;# Use vim keybindings in copy mode
setw -g mode-keys vi

# Setup 'v' to begin selection as in Vim （seems require Tmux 1.8）

# 一般情况中，&amp;lt;prefix&amp;gt;-[ 进入复制模式后 &amp;lt;space&amp;gt; 开始选中，&amp;lt;enter&amp;gt; 结束选中 (copy to buffer)

bind-key -t vi-copy v begin-selection
bind-key -t vi-copy y copy-pipe &quot;reattach-to-user-namespace pbcopy&quot;

# Update default binding of `Enter` to also use copy-pipe
unbind -t vi-copy Enter
bind-key -t vi-copy Enter copy-pipe &quot;reattach-to-user-namespace pbcopy&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;&amp;lt;prefix&amp;gt;-[&lt;/code&gt;进入 Tmux 的复制模式，使用 Vim 操作来进行移动，v 选中内容，y 进行复制，首先内容会复制到 Tmux 的 paste buffer 中，再由 pbcopy 来复制到系统的剪贴板中。&lt;/p&gt;

&lt;h3&gt;vim 的 paste mode&lt;/h3&gt;

&lt;p&gt;Vim中 ⌘+V 的粘贴
有时候如果我们想用 &lt;code&gt;⌘+v&lt;/code&gt; 来进行粘贴，直接粘贴的话内容是一段一段复制进去的，并且还伴有一些我们不希望出现的缩进或者其它奇怪的东西，我们可以进入 Vim 的 paste mode 来进行正常的粘贴。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;vim&quot;&gt;:set paste &quot;开启paste 模式
:set nopaste &quot;关闭paste 模式
:set pastetoggle &quot;toggle 模式
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Mon, 13 Jan 2014 00:00:00 +0800</pubDate>
        <link>/2014/01/13/paste-in-osx-terminal/</link>
        <guid isPermaLink="true">/2014/01/13/paste-in-osx-terminal/</guid>
      </item>
    
      <item>
        <title>shell 流控制</title>
        <description>&lt;h2&gt;shell流控制分类&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;判断 if&lt;/li&gt;
&lt;li&gt;分支判断case&lt;/li&gt;
&lt;li&gt;循环 for&lt;/li&gt;
&lt;li&gt;循环 while&lt;/li&gt;
&lt;li&gt;循环 until&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 其实概括起来，只是2类结构而已：&lt;code&gt;判断和循环&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;sh&quot;&gt;#!/bin/sh
if [commend1];then
    commend2
    ......
else
    commend3
    ......
fi
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;if条件判断&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;字符串判断&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;str1 = str2　　　　　　当两个串有相同内容、长度时为真&lt;/li&gt;
&lt;li&gt;str1 != str2　　　　　 当串str1和str2不等时为真&lt;/li&gt;
&lt;li&gt;-n str1　　　　　　　 当串的长度大于0时为真(串非空)&lt;/li&gt;
&lt;li&gt;-z str1　　　　　　　 当串的长度为0时为真(空串)&lt;/li&gt;
&lt;li&gt;str1　　　　　　　　   当串str1为非空时为真&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;数字的判断&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;int1 -eq int2　　　　两数相等为真&lt;/li&gt;
&lt;li&gt;int1 -ne int2　　　　两数不等为真&lt;/li&gt;
&lt;li&gt;int1 -gt int2　　　　int1大于int2为真&lt;/li&gt;
&lt;li&gt;int1 -ge int2　　　　int1大于等于int2为真&lt;/li&gt;
&lt;li&gt;int1 -lt int2　　　　int1小于int2为真&lt;/li&gt;
&lt;li&gt;int1 -le int2　　　　int1小于等于int2为真&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;文件的判断&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;-r file　　　　　用户可读为真&lt;/li&gt;
&lt;li&gt;-w file　　　　　用户可写为真&lt;/li&gt;
&lt;li&gt;-x file　　　　　用户可执行为真&lt;/li&gt;
&lt;li&gt;-f file　　　　　文件为正规文件为真&lt;/li&gt;
&lt;li&gt;-d file　　　　　文件为目录为真&lt;/li&gt;
&lt;li&gt;-c file　　　　　文件为字符特殊文件为真&lt;/li&gt;
&lt;li&gt;-b file　　　　　文件为块特殊文件为真&lt;/li&gt;
&lt;li&gt;-s file　　　　　文件大小非0时为真&lt;/li&gt;
&lt;li&gt;-t file　　　　　当文件描述符(默认为1)指定的设备为终端时为真&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;简单脚本示例&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;sh&quot;&gt;#!/bin/bash
i=&quot;shell&quot;
if [ &quot;$i&quot;==&quot;shell&quot; ]; then
    echo $i
else
    echo &quot;not shell&quot;
fi
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;总结的注意点&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;有点不习惯书写方式 如表达式 $i==shell 也成立 作为一个写php的觉得很不习惯&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[]&lt;/code&gt; 左右都要留一个空格&lt;/li&gt;
&lt;li&gt;&lt;code&gt;==&lt;/code&gt; 两边最好都要用&lt;code&gt;&quot;&quot;&lt;/code&gt;扩起来,防止有特殊的变量&lt;/li&gt;
&lt;li&gt;不要忘记fi&lt;/li&gt;
&lt;/ol&gt;

</description>
        <pubDate>Fri, 10 Jan 2014 00:00:00 +0800</pubDate>
        <link>/2014/01/10/condition-test/</link>
        <guid isPermaLink="true">/2014/01/10/condition-test/</guid>
      </item>
    
      <item>
        <title>陈小姐</title>
        <description>&lt;p&gt;几日前，有个多日不见的朋友和我诉苦，说是思念一个人，希望留下点回忆的东西，却总是得不到合适的寄托。他和我讲述了他和她的故事。故事不长，和那些烂长的小说故事比起来说甚至短的有点可怜，记下来一是因为白白听了别人一个故事，就当是做个寄托，二是因为确实是个好故事。&lt;/p&gt;

&lt;p&gt;好友暂称为E君 ，故事中的她暂称为陈小姐。&lt;/p&gt;

&lt;p&gt;陈小姐二十五岁，开心时笑起来特美，眼睛弯起来像月牙那样，仿佛能让人忘掉忧愁。&lt;/p&gt;

&lt;p&gt;和陈小姐的相遇算是机缘，他笑说一定是上辈子未尽的缘分，陈小姐也不反驳，只露出另一种醉人的微笑给予回应。&lt;/p&gt;

&lt;p&gt;E君在网上闲逛的时候遇到一个转让物品的帖子,价钱超乎寻常的低，大概意思就是由于搬家，低价转让。E君看了看价格，第一反应就是：是个骗子！ E君很生气，不过转念一想，反正上午没什么工作，就抽空好好“教育教育”这个家伙吧，&lt;/p&gt;

&lt;p&gt;“喂，你好”
出于应有的礼貌E君主动向对方问好。
“嗯，你好
” 电话的那头传来了一个女孩子的声音。&lt;/p&gt;

&lt;p&gt;E君听到对方的声音心里突然感觉有点慌，因为听着声音对方应该是个和自己差不多年纪的女孩，对于单身的E君来说这种同龄女孩子E君都会有莫名其妙的好感，（不要问我为什么，我自己也不知道），随带的便会感到紧张，手足无措，不知道说什么好，即便是我们的E君压根就不知道手机另外一端的这个女孩子张什么样子，仅仅是就听了她说“嗯，你好”，当然还有一个更加简单而又重要的原因:&quot;这个声音很好听~ E君心里想着，这么好听的声音怎么可能是一个骗子的，不对，应该是一个骗子怎么可能会有这么好听的声音。总而言之，E君奇怪的逻辑又开始作祟了，E君忽然觉得对不起这个仅仅就听对方说了一句话的女孩子，不应该把她定义成一个骗子。只是E君的这些想法对于在电话另一端的女孩子来说，全然不知。&lt;/p&gt;

&lt;p&gt;”今天晚上，地铁口面交“&lt;/p&gt;

&lt;p&gt;E君来到了和女孩约定的地铁口，时间正好，E君拿出了手机拨了那个女孩的电话&lt;/p&gt;

&lt;p&gt;“喂，你在哪，我已经到了” E君和女孩子说着
“嗯，我就在出口着”  电话里传来了那个女孩子的声音，E君忽然觉得这个声音是那么的熟悉，整整一个下午在脑海中回荡的那个声音，那个像是魔豆一样落地就疯狂生长，缠绕着E君脑海的声音，再一次听到，仿佛什么东西突然苏醒了一样，让E君就这样愣在了那里。而就在这时，E君看到了一个女子，相距30米外，笑着，一手扶着头发，另外一只手中垂着还未挂掉的电话。&lt;/p&gt;

&lt;p&gt;这是E君和她第一次见面，在后来的日子里，有的时候E君躺在床上也会回忆那天晚上见面的场景，每一个细节，每一个动作E君都很贪婪的想把它们想起来，然后E君就会开始用双手敲打自己的头，厉声的骂自己为什么都当时怎么就没有好好的记住，E君也未曾想到自己会如此的渴望多记得一点，自己会如此的念念不忘。&lt;/p&gt;
</description>
        <pubDate>Wed, 08 Jan 2014 00:00:00 +0800</pubDate>
        <link>/2014/01/08/Miss-Chen/</link>
        <guid isPermaLink="true">/2014/01/08/Miss-Chen/</guid>
      </item>
    
  </channel>
</rss>
